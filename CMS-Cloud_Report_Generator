function onOpen(e){
    // Create menu options
    var ui = SpreadsheetApp.getUi();
    ui.createMenu('Score & Report')
      .addItem('Tabulate Scores','Tabulate')
      .addItem('Score Pillars','Pillar_Score')
      .addItem('Score Functions','Function_Score')
      .addItem('Create Reports','Generate_Report')
      .addItem('MAKE THE REPORTS!','Generate_Slides') 
      .addToUi();
};

function Tabulate() {
  var sheet = SpreadsheetApp.getActiveSpreadsheet();
  var shAnswers = sheet.getSheetByName('Zero Trust Data Call');
  var shOptions = sheet.getSheetByName("QA");
  var shScores = sheet.getSheetByName("Scoring");

  var col_loop = 61;
  var row_loop = 7;
  var entry_loop = shAnswers.getLastRow();
  // Variables for column end pillar association
  var devPillar = 9;
  var idnPillar = 28;
  var netPillar = 39;
  var appPillar = 47;
  var datPillar = 53;
  var vizPillar = 60;
  
  //set up data range variables
  var answers = shAnswers.getRange(1,1,entry_loop,col_loop).getValues();  //(row, col, # rows, # cols)
  var options = shOptions.getRange(1,1,row_loop,col_loop).getValues();
  var scores = shScores.getRange(1,1,row_loop,col_loop).getValues();
  var out_row = new Array(col_loop);
  var tmp_score = 0;
  var skip = false;

  // Loop Each answer row
  // <= was causing an off by one error
  for ( count =1; count<entry_loop; count++ ) {

    // Copy ADO info to result
    for (var i=0; i<5; i++) { 
      ado_info = answers[count][i];
      out_row[i] = ado_info; }

    //Score answers
    for ( var col_counter =5; col_counter<col_loop ;col_counter++ ) {
      for ( var row_counter =1; row_counter<row_loop ;row_counter++ ) {
        
        // Compare answer key to selected answer to determine if selected has answer option
        // console.log(answers[count][col_counter].toString() + " vs.  " + options[row_counter][col_counter].toString())
        // Test for blank answer so score isn't factored
        if ( answers[count][col_counter].toString() == "" ) { skip=true; break; }
        // Should the indices for answer[][] change each time?  Maybe use count?
        // And should you reverse the includes?  Answers includes Options??
        if (answers[count][col_counter].toString().includes(options[row_counter][col_counter].toString())) {
          tmp_score += Number(scores[row_counter][col_counter]);
        }
      }
      out_row[col_counter] = tmp_score;
      tmp_score = 0;
    }

    // console.log("Out Length: " + out_row.length);
    var outMatrix = [];
    outMatrix.push(out_row);

    // Output test
    var shOut = sheet.getSheetByName("TEST").getRange(count,1,1,col_loop);
    console.log("Output Range: "+ shOut.getA1Notation())
    shOut.setValues(outMatrix);
  }
}

function vizTabulate() {
  var sheet = SpreadsheetApp.getActiveSpreadsheet();
  var shAnswers = sheet.getSheetByName('Zero Trust Data Call');
  var shOptions = sheet.getSheetByName("QA");
  var shScores = sheet.getSheetByName("Scoring");

  var col_loop = 61;
  var row_loop = 7;
  var entry_loop = shAnswers.getLastRow();
  // Variables for column end pillar association
  var devPillar = 9;
  var idnPillar = 28;
  var netPillar = 39;
  var appPillar = 47;
  var datPillar = 53;
  var vizPillar = 60;
  
  //set up data range variables
  var answers = shAnswers.getRange(1,1,entry_loop,col_loop).getValues();  //(row, col, # rows, # cols)
  var options = shOptions.getRange(1,1,row_loop,col_loop).getValues();
  var scores = shScores.getRange(1,1,row_loop,col_loop).getValues();
  var out_row = new Array(col_loop);
  var currentAnswer = "";

  // Loop Each answer row
  // <= was causing an off by one error
  for ( count =1; count<entry_loop; count++ ) {
    var viz = {'device': 0, 'network':0, 'application':0, 'identity': 0,  'data':0};
    // Score answers
    // Visibility and Analysis for Devices, Network, and Applications
    // Logs are generated by:
    currentAnswer = answers[count][53].toString();
    if (currentAnswer.includes(options[1][53].toString()) || currentAnswer.includes(options[3][53].toString())) {
      viz['device'] += 0.5;
    }
    if (currentAnswer.includes(options[5][53].toString())) {
      viz['network'] += 0.5;
    }
    if (currentAnswer.includes(options[2][53].toString()) || currentAnswer.includes(options[4][53].toString()) || currentAnswer.includes(options[6][53].toString())) {
      viz['application'] += 0.5;
    }

    // Logs from which of the following are centrally reported: 
    currentAnswer = answers[count][54].toString();
    if (currentAnswer.includes(options[1][54].toString()) || currentAnswer.includes(options[3][54].toString())) {
      viz['device'] += 0.5;
    }
    if (currentAnswer.includes(options[5][54].toString())) {
      viz['network'] += 0.5;
    }
    if (currentAnswer.includes(options[2][54].toString()) || currentAnswer.includes(options[4][54].toString()) || currentAnswer.includes(options[6][54].toString())) {
      viz['application'] += 0.5;
    }

    // Log data is used to monitor:	D=1, N=4, A=2,3 D=5
    currentAnswer = answers[count][55].toString();
    if (currentAnswer.includes(options[1][55].toString())) {
      viz['device'] += 0.5;
    }
    if (currentAnswer.includes(options[4][55].toString())) {
      viz['network'] += 0.5;
    }
    if (currentAnswer.includes(options[2][55].toString()) || currentAnswer.includes(options[3][55].toString())) {
      viz['application'] += 0.5;
    }
    if (currentAnswer.includes(options[5][55].toString())) {
      viz['data'] += 1.5;
    }

    // Security alerts are generated from the logs of:
    currentAnswer = answers[count][57].toString();
    if (currentAnswer.includes(options[1][57].toString()) || currentAnswer.includes(options[3][57].toString())) {
      viz['device'] += 0.5;
    }
    if (currentAnswer.includes(options[5][57].toString())) {
      viz['network'] += 0.5;
    }
    if (currentAnswer.includes(options[2][57].toString()) || currentAnswer.includes(options[4][57].toString()) || currentAnswer.includes(options[6][57].toString())) {
      viz['application'] += 0.5;
    }

    var overall = 0;
    // Log analysis is: Manual; Alerts based on static rules; Alerts utilizing machine learning
    currentAnswer = answers[count][56].toString();
    if (currentAnswer.includes(options[3][56].toString())) {
      // Alerts use ML, +.5 to everyone
      overall += .5;
    } else if (currentAnswer.includes(options[2][56].toString())) {
      // Alerts are static, +.25 to everyone
      overall += .25;
    }

    // Alerts from log analysis are handled: Manually; Partial machine intervention; Automated response and changes
    currentAnswer = answers[count][58].toString();
    if (currentAnswer.includes(options[3][58].toString())) {
      // AutoResponse, +.5 to everyone
    } else if (currentAnswer.includes(options[2][58].toString())) {
      // Alerts are static, +.25 to everyone
      overall += .25;
    }

    // Compliance controls are evaluated:  Manually; At deployment by an automated system; During development by an automated system; Continuously throughout system lifecycle
    currentAnswer = answers[count][59].toString();
    if (currentAnswer.includes(options[4][59].toString())) {
      viz['device'] +=1;
    } else if (currentAnswer.includes(options[3][59].toString())) {
      viz['device'] += 0.5;
    } else if (currentAnswer.includes(options[2][59].toString())) {
      viz['device'] += 0.25;
    } 

    var identTypes = answers[count][15];
    if (identTypes.includes("Humans")) {
      // Identity logging -- assumptions being made based on who they use for User and NPE stores
      // IDM/Okta provided by DIMES, SLS, HARP, Amazon Cognito, Other
      currentAnswer = answers[count][17].toString();
      if (currentAnswer == options[5][17].toString() || currentAnswer == "") {
        viz['identity'] += 0;
      } else {
        viz['identity'] += 2;
      } 
    }
    if (identTypes.includes("API")) {
      // JWT, API Key, PKI, Cognito, Other
      currentAnswer = answers[count][22].toString();
      if (currentAnswer == options[5][22].toString() || currentAnswer == "") {
        viz['identity'] += 0;
      } else if (currentAnswer.includes(options[1][22].toString()) || currentAnswer.includes(options[3][22].toString())) {
        viz['identity'] += 1;
      } else {
        viz['identity'] += 2;
      }
    }
    if (identTypes.includes("Humans") && identTypes.includes("API")) {
      viz['identity'] = Math.round((viz['identity']/2 * 100)/ 100);
    }
    
    // device is the only one that can get over 3, so if it is, knock it down to 3.
    viz['device'] += overall;
    if (viz['device'] > 3) {
      viz['device'] = 3;
    }
    out_row = [viz['device'], viz['identity'], viz['network']+overall, viz['application']+overall, viz['data']];
    var outMatrix = [];
    outMatrix.push(out_row);

    // Output test
    var shOut = sheet.getSheetByName("TEST").getRange(count,col_loop+1,1,5);
    console.log("Output Range: "+ shOut.getA1Notation())
    shOut.setValues(outMatrix);
  }

}
//
// Pillar Scores
//
function Pillar_Score() {
  var sheet = SpreadsheetApp.getActiveSpreadsheet();
  var shOut = sheet.getSheetByName("TEST");
  var shPillar = sheet.getSheetByName("TEST_PILLAR")

  var col_loop = 61;
  var entry_loop = shOut.getLastRow();
  // Variables for column end pillar association
  var devPillar = 9;
  var idnPillar = 28;
  var netPillar = 39;
  var appPillar = 47;
  var datPillar = 53;
  var vizPillar = 60;

  console.log("entry_loop: "+entry_loop);

  var results = shOut.getRange(1,1,entry_loop,col_loop).getValues();  // QQ Scores

  // Loop Each answer row
  // <= was causing an off by one error
  for ( count =1; count<entry_loop; count++ ) {
    console.log("LOOP ENTRY");
    var devScore = 0;
    var idnScore = 0;
    var netScore = 0;
    var appScore = 0;
    var datScore = 0;
    var vizScore = 0;
    var tmp_Score = 0;
    var outRow = [];
    
    console.log("out Name: "+results[count][0]);
    outRow.push(results[count][0]);

    for ( var c = 5; c<devPillar; c++ ){
      console.log("Dev Loop: "+results[count][c]);
      tmp_Score += Number(results[count][c]);
    }
    console.log("Dev Tot: "+tmp_Score);
    console.log("Dev Divisor: "+(devPillar-5));
    devScore = Math.round(tmp_Score/(devPillar-5) * 100) / 100;
    console.log("Dev: "+devScore);
    outRow.push(devScore);

    tmp_Score = 0;
    for ( var c = devPillar; c<idnPillar; c++ ){
      tmp_Score += Number(results[count][c]);
    }
    idnScore = Math.round(tmp_Score/(idnPillar-devPillar) * 100) / 100;
    console.log("Idn: "+idnScore);
    outRow.push(idnScore);

    tmp_Score = 0;
    for ( var c = idnPillar; c<netPillar; c++ ){
      tmp_Score += Number(results[count][c]);
    }
    netScore = Math.round(tmp_Score/(netPillar-idnPillar) * 100) / 100;
    console.log("Net: "+netScore);
    outRow.push(netScore);

    tmp_Score = 0;
    for ( var c = netPillar; c<appPillar; c++ ){
      tmp_Score += Number(results[count][c]);
    }
    appScore = Math.round(tmp_Score/(appPillar-netPillar) * 100) / 100;
    console.log("App: "+appScore);
    outRow.push(appScore);

    tmp_Score = 0;
    for ( var c = appPillar; c<datPillar; c++ ){
      tmp_Score += Number(results[count][c]);
    }
    datScore = Math.round(tmp_Score/(datPillar-appPillar) * 100) / 100;
    console.log("Dat: "+datScore);
    outRow.push(datScore);

    tmp_Score = 0;
    for ( var c = datPillar; c<vizPillar; c++ ){
      tmp_Score += Number(results[count][c]);
    }
    vizScore = Math.round(tmp_Score/(vizPillar-datPillar) * 100) / 100;
    console.log("Viz: "+vizScore);
    outRow.push(vizScore);

    var outPillar = shPillar.getRange(count+1,1,1,outRow.length);  

    var outMatrix = [];
    outMatrix.push(outRow);
    outPillar.setValues(outMatrix);

  }
}

//
// Function Scores
//
function Function_Score(count) {
  var sheet = SpreadsheetApp.getActiveSpreadsheet();
  var fnOut = sheet.getSheetByName("TEST_MAP").getRange(1,1,10,2);

  var shFnMap = sheet.getSheetByName("Mapping");
  var fnMap = shFnMap.getRange(1,1,11,12).getValues();


  var col_loop = 66;
  var shScores = sheet.getSheetByName("TEST")
  var entry_loop = shScores.getLastRow();
  var scoresRng = shScores.getRange(1,1,entry_loop,col_loop).getValues();

  var pillarcount = 0;
  var tmpQRef;

  do {
    var fnScore = [];
    var pillar = fnMap[0][pillarcount];
    var fnMax = fnMap[0][pillarcount+1];
    var fnCount = 0;
    var pillarTmpScore = 0;

    //Copy Function Name
    fnScore.push([pillar,0]);

    //Score each Function
    for ( var y=1; y<=fnMax; y++ ){
      tmpScore = 0;

      // Skip the score splitting if there is no matching question
      if (fnMap[y][pillarcount+1].toString() == "") {
        tmpScore = "N/A";
      } 
      else { // Split fn map to Q numbers
        tmpQRef = fnMap[y][pillarcount+1].toString().split(",");
        // Add score of each Q together
        for (var z=0; z<tmpQRef.length; z++ ) {
          var questionColumn = Number(tmpQRef[z]);     // Get Q score
          tmpScore += scoresRng[count][questionColumn-1];    // Add to temp total
        }
        tmpScore = (tmpScore/tmpQRef.length).toFixed(2);
        fnCount++;
        pillarTmpScore += tmpScore;
      }
      fnScore.push([fnMap[y][pillarcount], tmpScore]);      // Need to push an array here, and make a cell for the value you want to set in the next 
    }

    pillarTmpScore = (pillarTmpScore/fnCount).toFixed(2);
    fnScore[0][1] = pillarTmpScore;
    
    // Output Pillar/Fn Score
    fnOut = sheet.getSheetByName("TEST_MAP").getRange(1,pillarcount+1,fnMax+1,2);
    fnOut.setValues(fnScore);

    // Go to next pillar
    pillarcount += 2;
  }while (pillarcount<=9)
}

/*

          TEMP REMOVE ELIZABETH FUNCTION SCORE

          WAS CREATING GIANT NUMBERS

//
// Function Scores
//
function Function_Score() {
  var sheet = SpreadsheetApp.getActiveSpreadsheet();
  var fnOut = sheet.getSheetByName("TEST_MAP").getRange(1,1,10,2);

  var shFnMap = sheet.getSheetByName("Mapping");
  var fnMap = shFnMap.getRange(1,1,11,12).getValues();

  var count = 12;  // Using FFM since it was filled out by another team

  var col_loop = 66;
  var shScores = sheet.getSheetByName("TEST")
  var entry_loop = shScores.getLastRow();
  var scoresRng = shScores.getRange(1,1,entry_loop,col_loop).getValues(); // Data Call Scores

  var pillarcount = 0;
  var tmpQRef;

  do {
    //Copy Function Names
    var fnScore = []; 
    var pillar = fnMap[0][pillarcount];
    var fnMax = fnMap[0][pillarcount+1];
    var fnCount = 0;
    var pillarTmpScore = 0;
    fnScore.push([pillar,0]);
    //Score each Function
    for ( var y=1; y<=fnMax; y++ ){
      console.log("Fn Name: "+fnMap[y][pillarcount]);    // For some reason this fails either after 1 or 3 loops depending on how I initialize the array
      console.log("X: "+y);
      tmpScore = 0;
      // Split fn map to Q numbers
      if (fnMap[y][pillarcount+1].toString() == "") {
        // Skip the score splitting if there is no matching question
        tmpScore = "N/A";
      } else {
        tmpQRef = fnMap[y][pillarcount+1].toString().split(",");
        // Add score of each Q together
        for (var z=0; z<tmpQRef.length; z++ ) {
          var questionColumn = Number(tmpQRef[z]); 
          // put in it's own variable for clarity, must subtract 1 because arrays are 0 indexed, but Sheets are 1 indexed
          tmpScore += scoresRng[count][questionColumn-1];
        }
        // Produce fn score average -- this is the best way to round to a specific decimal in Javascript
        tmpScore = Math.round((tmpScore/tmpQRef.length) * 100) / 100;
        fnCount++;
        pillarTmpScore += tmpScore;
      }
      fnScore.push([fnMap[y][pillarcount], tmpScore]);      // Need to push an array here, and make a cell for the value you want to set in the next 
    }
    
    pillarTmpScore = Math.round((pillarTmpScore/fnCount) * 100) / 100;
    fnScore[0][1] = pillarTmpScore;
    
    // Output Pillar/Fn Score
    fnOut = sheet.getSheetByName("TEST_MAP").getRange(1,pillarcount+1,fnMax+1,2);
    fnOut.setValues(fnScore);

    // Go to next pillar
    pillarcount += 2;
  }while (pillarcount<=9)
}
*/
//
// Function Scores
//
function Function_Score_horizontal() {
  var sheet = SpreadsheetApp.getActiveSpreadsheet();
  var fnOut = sheet.getSheetByName("Functions-Horizontal").getRange(1,1,2,39);

  var shFnMap = sheet.getSheetByName("Mapping");
  var fnMap = shFnMap.getRange(1,1,11,12).getValues();

  var col_loop = 66;
  var shScores = sheet.getSheetByName("TEST")
  var entry_loop = shScores.getLastRow();
  var scoresRng = shScores.getRange(1,1,entry_loop,col_loop).getValues(); // Data Call Scores
  

  for (count = 1; count < entry_loop; count++) {
    var pillarcount = 0;
    var tmpQRef;

    var fnScores = [];

    //get the name of the system
    fnScores.push(scoresRng[count][0]);
    console.log(scoresRng[count]);

    do {
      //How many functions in the pillar?
      var fnMax = fnMap[0][pillarcount+1];

      //Score each Function
      for ( var y=1; y<=fnMax; y++ ){
        tmpScore = 0;

        // Split fn map to Q numbers
        if (fnMap[y][pillarcount+1].toString() == "") {
          // Skip the score splitting if there is no matching question
          tmpScore = "N/A";
        } else {
          tmpQRef = fnMap[y][pillarcount+1].toString().split(",");
          // Add score of each Q together
          for (var z=0; z<tmpQRef.length; z++ ) {
            var questionColumn = Number(tmpQRef[z]); 
            // put in it's own variable for clarity, must subtract 1 because arrays are 0 indexed, but Sheets are 1 indexed
            tmpScore += scoresRng[count][questionColumn-1];
          }
          // Produce fn score average -- this is the best way to round to a specific decimal in Javascript
          tmpScore = tmpScore/tmpQRef.length.toFixed(2);
          
        }
        fnScores.push(tmpScore); 
      }    
      // Go to next pillar
      pillarcount += 2;
    }while (pillarcount<=9)
        // Output Pillar/Fn Score
      var outMatrix = [];
      outMatrix.push(fnScores);
      fnOut = sheet.getSheetByName("Functions-Horizontal").getRange(count+1,1,1,39);
      fnOut.setValues(outMatrix);
  }
}

function identityScores() {
  var sheet = SpreadsheetApp.getActiveSpreadsheet();
  var shAnswers = sheet.getSheetByName('Zero Trust Data Call');

  var col_loop = 61;
  var numEntries = shAnswers.getLastRow();
  
  //set up data range variables
  var answers = shAnswers.getRange(1,1,numEntries,col_loop).getValues();  //(row, col, # rows, # cols)

  var shTest = sheet.getSheetByName("TEST");

  for ( count =1; count<numEntries; count++ ) {
    var currentAnswer = "";
    var tmp_Score = 0;
    var out_row = shTest.getRange(count,1,1,col_loop).getValues();
    // Column 11 = do you only use CloudTamer?
    // If so, Is MFA required for Devs is True, so set it
    if (answers[count][10].toString() == 'false') {
      out_row[0][12] = 2;
    }

    // MFA for Devs score:
    // Email, SMS, OTP or Push from an authenticator app, e.g. Google Authenticator, DUO, 
    //  One time PIN from a hardware token, e.g. RSA SecurID, PIV/certificate, FIDO2/WebAuthn (includes YubiKey), None
    currentAnswer = answers[count][11].toString();
    if ((currentAnswer.includes("PIV") || currentAnswer.includes("FIDO2")) 
      && (!currentAnswer.includes("Email") && !currentAnswer.includes("SMS") && !currentAnswer.includes("OTP") && !currentAnswer.includes("RSA"))) {
      tmp_Score = 3;
    } else if (currentAnswer == "None") {
      tmp_Score = 1;
    } else {
      tmp_Score = 2;
    }
    out_row[0][11] = tmp_Score;

    // MFA for Users score:
    currentAnswer = answers[count][18].toString();
    if ((currentAnswer.includes("PIV") || currentAnswer.includes("FIDO2")) 
      && (!currentAnswer.includes("Email") && !currentAnswer.includes("SMS") && !currentAnswer.includes("OTP") && !currentAnswer.includes("RSA"))) {
      tmp_Score = 3;
    } else if (currentAnswer == "None") {
      tmp_Score = 1;
    } else {
      tmp_Score = 2;
    }
    out_row[0][18] = tmp_Score;

    // How are Identity risks Identified?  #15 and #21, #28, #24
    out_row[0][14] = calcRisk(currentAnswer = answers[count][14].toString());
    out_row[0][20] = calcRisk(currentAnswer = answers[count][20].toString());
    out_row[0][23] = calcRisk(currentAnswer = answers[count][23].toString());
    out_row[0][27] = calcRisk(currentAnswer = answers[count][27].toString());
  
  // Different Permissions: 14, 22, 25
    out_row[0][13] = calcPerms(answers[count][13].toString());
    out_row[0][21] = calcPerms(answers[count][21].toString());
    out_row[0][24] = calcPerms(answers[count][24].toString());

  // API AuthN #23
  // JSON Web Token (JWT), API Key, Device PKI, Amazon Cognito, Other
    currentAnswer = answers[count][22].toString();
    if (currentAnswer.includes("PKI") || currentAnswer.includes("JWT") || currentAnswer.includes("API")) {
      tmp_Score = 2;
    } else if (currentAnswer.includes("Other") || currentAnswer.includes("Cognito")) {
      tmp_Score = 1;
    }
    out_row[0][22] = tmp_Score;  

  // VM AuthN #27
  // Device PKI, Network Access Control, AWS IAM, Trusted Platform Module/Hardware Security Module, Other
  // 3, 2, 2, 3, 1
    currentAnswer = answers[count][26].toString();
    if (currentAnswer.includes("PKI") || currentAnswer.includes("Trusted")) {
      tmp_Score = 3;
    } else if (currentAnswer.includes("Network") || currentAnswer.includes("IAM")) {
      tmp_Score = 2;
    } else if (currentAnswer.includes("Other")) {
      tmp_Score = 1;
    }
    out_row[0][26] = tmp_Score;

    // And now save these
    var outMatrix = [];
    outMatrix.push(out_row);
    var testOut = shTest.getRange(count,1,1,col_loop);
    testOut.setValues(out_row);
  }
}

function calcPerms(currentAnswer) {
  // The same permissions are granted each time, 1
  // Permissions are granted Just in Time (JIT), e.g. a role is assigned they log in and is removed at logout, 2
  // Permissions are granted just for the actions they are trying to complete Just Enough Access (JEA), 3
  // Elevated permissions, e.g. administrator access, is only granted when request aka Just Enough Privilege (JEP) 3

  var tmp_Score;
  if (currentAnswer.includes("JEP") || currentAnswer.includes("JEA")) {
    tmp_Score = 3;
  } else if (currentAnswer.includes("JIT") ) {
    tmp_Score = 2;
  } else if (currentAnswer.includes("same")) {
    tmp_Score = 1;
  }
  return tmp_Score;
}

function calcRisk(currentAnswer) {
  // External notifications (includes relying on CMS Cloud) 2, Periodic account reviews 1, Simple and static analysis rules 2, 
  //  Real time analytics 2, Machine Learning behavior analytics 3

  var tmp_Score;
  if (currentAnswer.includes("Machine")) {
    tmp_Score = 3;
  } else if (currentAnswer.includes("External") || currentAnswer.includes("Static") || currentAnswer.includes("Periodic")) {
    tmp_Score = 2;
  } else {
    tmp_Score = 1;
  }
  return tmp_Score;
}

//
//  Generate Pillar Radar chart
//
function Generate_Report(rowADO) {
  var sheet = SpreadsheetApp.getActiveSpreadsheet();
  var fnOut = sheet.getSheetByName("OUTPUT");
  var shPillar = sheet.getSheetByName("TEST_PILLAR");

  //var rowADO = 12;  // TEMP

  var tmpPillarNames = shPillar.getRange(1,1,1,7).getValues();
  var tmpPillarScores = shPillar.getRange(rowADO-1,1,1,7).getValues();


  tmpRng = fnOut.getRange(1,1,2,7);
  var chartData = tmpRng.getValues();
  
  for (var j=0;j<7;j++){
    chartData[0][j] = tmpPillarNames[0][j];
  }
  for (var j=0;j<7;j++){
    chartData[1][j] = tmpPillarScores[0][j];
  }
  
  tmpRng.setValues(chartData)

  var chart = fnOut.newChart()
  .addRange(tmpRng)
  .setChartType(Charts.ChartType.RADAR)
  .setNumHeaders(1)
  .setOption("useFirstColumnAsDomain", true)
  .setTransposeRowsAndColumns(true)
  .setOption("vAxis.minValue",0)
  .setOption("vAxis.maxValue",3)
  .setOption("pointShape","square")
  .setOption("pointSize",5)
  .setPosition(5,2,0,0)
  .setOption("legend", {position: 'bottom', textStyle: {fontSize: 12}});

  fnOut.insertChart(chart.build());

}


//
//  Generate Slides output
//
function Generate_Slides() {
  // Get and copy slides Template File
  var templateId = "ZTMM_Results_Template";
  // Create a copy of the presentation using DriveApp
  var template = DriveApp.getFilesByName(templateId).next();
  
  // Create Folder for report output
  var date = new Date();
  var dateRun = date.getFullYear()+"-"+(date.getMonth()+1);
  var parentFolderID = template.getParents().next().getId();
  var parentFolder = DriveApp.getFolderById(parentFolderID);
  var outFolder = parentFolder.createFolder(dateRun+"_Reports");


  //var count = 88;   // TEST TO BE REMOVED


  //Set up text replacement variables
  var name = "{{ADO_Name}}"   // ADO Name
  var subdate = "{{Submission_Date}}"   // Data Call submission date
  var project = "{{Sub_FISMA}}"  // [Optional] Sub project name
  var contact = "{{Contact}}"  // Associated ADO contact email
  var pillars = "{{Pillars}}"  // Text of pillar scores
  var chart = "{{Radar}}"  // Generated chart
  var functions = "{{Functions}}"  // Text of function scores
  // Image placement variables
  var position = {left: 135, top: 159};
  var size = {width: 386, height: 239};

  // Set up sheet data variables
  var sheet = SpreadsheetApp.getActiveSpreadsheet();
  var shRadar = sheet.getSheetByName("OUTPUT");
  var shPillar = sheet.getSheetByName("TEST_PILLAR");
  var shMap = sheet.getSheetByName("TEST_MAP");
  var shScores = sheet.getSheetByName("TEST");

  //Get info data for all ADOs
  var rowTot = shScores.getLastRow();
  var rngData = shScores.getRange(1,1,rowTot,5).getValues();
  var rngSubDate = sheet.getSheetByName('Zero Trust Data Call').getRange(1,63,rowTot,1).getValues();

  //Loop through each ADO
  for (var count=85;count<=rowTot;count++) {

    var slides_out = template.makeCopy("WORKING",outFolder);

    // Set current copy as active slides
    var slideFile = SlidesApp.openById(slides_out.getId());

    // Write ADO info to slide
    slideFile.replaceAllText(name, rngData[count-2][0]);
    slideFile.replaceAllText(project, rngData[count-2][1]);
    slideFile.replaceAllText(contact, rngData[count-2][4]);
    slideFile.replaceAllText(subdate, rngSubDate[count-2][0]);

    // Create data in sheets for individual ADO and write to new file
    Generate_Report(count); // Writes pillar score and chart to "OUTPUT" sheet
    Function_Score(count-2); // Writes function scores to "TEST_MAP" sheet (Num shift due to headers)
    var datPillar = shRadar.getRange(1,1,2,7).getValues(); 
    var datFunction = shMap.getRange(1,1,11,10).getValues(); 
    //VERY DUMB array->table pasting
    //PILLAR FIRST
    // Insert generated radar chart in slide
    var chtImage = shRadar.getCharts()[0];
    var slide = slideFile.getSlides()[3];
    slide.insertSheetsChartAsImage(
      chtImage,
      position.left,
      position.top,
      size.width,
      size.height);
    var tblEdit = slide.getTables()[0];
    for (var r = 0; r < 2; r++) {
      for (var c = 0; c < 7; c++) {
        tblEdit.getCell(r, c).getText().setText(datPillar[r][c]);
      }
    }
    // Delete chart from sheets file for next run
    shRadar.removeChart(chtImage);

    // NOW, FUNCTIONS! HUZZAH.
    slide = slideFile.getSlides()[4];
    tblEdit = slide.getTables()[0];
    for (r = 0; r < 11; r++) {
      for (c = 0; c < 10; c++) {
        if (isNaN(datFunction[r][c])) { tblEdit.getCell(r, c).getText().setText(datFunction[r][c]); }
        //if (r==9 && c==4) { tblEdit.getCell(r, c).getText().setText("A"); }
        else if(datFunction[r][c] == ""){ tblEdit.getCell(r, c).getText().setText(""); }
        else if(datFunction[r][c]<1.74){ tblEdit.getCell(r, c).getText().setText("T"); }
        else if(datFunction[r][c]>1.74 && datFunction[r][c]<=2.65){ tblEdit.getCell(r, c).getText().setText("A"); }
        else if(datFunction[r][c]>2.65){ tblEdit.getCell(r, c).getText().setText("O"); }
      }
    }

    // Rename new slides file to associated ADO report
    if (!(rngData[count][1].toString() == "")) {
      slides_out.setName(rngData[count-2][0]+"-"+rngData[count][1]+"_ZTMM-Results"); //If sub-name exists
    } else {
      slides_out.setName(rngData[count-2][0]+"_ZTMM-Results");
    }

  }   // Row->File iterator loop


}


function PDF_Save() {
  var refFile = DriveApp.getFileById("");
  var parentFolder = refFile.getParents().next();
  var fileList = parentFolder.getFiles();

  while(fileList.hasNext()) {
    var srcfile = fileList.next()
    var file = srcfile.makeCopy("PDF-TEST");

    var blob = file.getBlob().setName(`${srcfile.getName()}.pdf`);
    DriveApp.getFolderById(parentFolder.getId()).createFile(blob);
  }

}
